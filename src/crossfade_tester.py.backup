#!/usr/bin/env python3
"""
Interactive Crossfade Loop Tester
Test crossfade looping with any WAV file, adjust in real-time.
"""

import os
import sys
import json
import time
import threading
import numpy as np
import sounddevice as sd
import soundfile as sf
import select
import tty
import termios

class CrossfadeTester:
    """Interactive tester for crossfade looping."""
    
    def __init__(self):
        self.sample_rate = 44100
        self.buffer_size = 1024
        
        # Audio state
        self.audio_data = None
        self.position = 0
        self.crossfade_ms = 1000  # Default 1 second
        self.crossfade_samples = 0
        self.is_playing = False
        self.continuous_mode = False
        self.play_once_mode = False
        self.loops_completed = 0
        
        # File info
        self.current_file = None
        self.file_duration = 0
        
        # Terminal state
        self.running = True
        self.old_termios = None
        
        print("\n" + "="*60)
        print("INTERACTIVE CROSSFADE LOOP TESTER")
        print("="*60)
    
    def setup_terminal(self):
        """Setup terminal for single-character input."""
        self.old_termios = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
    
    def restore_terminal(self):
        """Restore terminal settings."""
        if self.old_termios:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_termios)
    
    def list_wav_files(self, directory):
        """List all WAV files in directory with durations."""
        files = []
        if os.path.exists(directory):
            for f in sorted(os.listdir(directory)):
                if f.lower().endswith('.wav'):
                    path = os.path.join(directory, f)
                    try:
                        data, sr = sf.read(path)
                        duration = len(data) / sr
                        files.append((f, duration, path))
                    except:
                        files.append((f, 0, path))
        return files
    
    def select_file(self):
        """Let user select a WAV file to test."""
        directory = "samples/real_test"
        files = self.list_wav_files(directory)
        
        if not files:
            print(f"\n‚ùå No WAV files found in {directory}/")
            print("Please place your test files there.")
            return False
        
        print(f"\nFiles in {directory}/:")
        for i, (name, duration, path) in enumerate(files, 1):
            print(f"[{i}] {name} ({duration:.1f}s)")
        
        print(f"[{len(files)+1}] Quit")
        
        while True:
            try:
                choice = input(f"\nSelect file (1-{len(files)+1}): ").strip()
                if not choice:
                    continue
                
                if choice.lower() == 'q':
                    return False
                
                choice_idx = int(choice) - 1
                
                if choice_idx == len(files):
                    return False  # Quit option
                
                if 0 <= choice_idx < len(files):
                    name, duration, path = files[choice_idx]
                    return self.load_file(path, name, duration)
                
                print(f"Please enter 1-{len(files)+1}")
                
            except (ValueError, KeyboardInterrupt):
                print("Invalid selection")
    
    def load_file(self, filepath, filename, duration):
        """Load a WAV file and its config if exists."""
        try:
            # Load audio
            data, sr = sf.read(filepath, always_2d=True)
            
            # Resample if needed
            if sr != self.sample_rate:
                print(f"Resampling {sr}Hz ‚Üí {self.sample_rate}Hz")
                scale = self.sample_rate / sr
                new_length = int(len(data) * scale)
                indices = np.linspace(0, len(data)-1, new_length).astype(int)
                data = data[indices]
            
            # Ensure stereo
            if data.shape[1] == 1:
                data = np.column_stack((data, data))
            
            # Store
            self.audio_data = data
            self.current_file = filepath
            self.filename = filename
            self.file_duration = duration
            self.position = 0
            self.loops_completed = 0
            
            # Load existing config if available
            config_path = filepath.replace('.wav', '.txt')
            if os.path.exists(config_path):
                try:
                    with open(config_path, 'r') as f:
                        config = json.load(f)
                        if 'crossfade_ms' in config:
                            self.crossfade_ms = config['crossfade_ms']
                            print(f"Loaded crossfade: {self.crossfade_ms}ms")
                except:
                    print("Could not load config, using default")
            
            # Calculate samples
            self.crossfade_samples = int(self.crossfade_ms * self.sample_rate / 1000)
            
            print(f"\n‚úÖ Loaded: {filename}")
            print(f"   Duration: {duration:.1f} seconds")
            print(f"   Crossfade: {self.crossfade_ms}ms ({self.crossfade_samples} samples)")
            
            return True
            
        except Exception as e:
            print(f"Error loading {filepath}: {e}")
            return False
    
    def save_config(self):
        """Save current crossfade to .txt file."""
        if not self.current_file:
            return
        
        config_path = self.current_file.replace('.wav', '.txt')
        config = {
            "crossfade_ms": self.crossfade_ms,
            "strategy": "crossfade",
            "saved_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        try:
            with open(config_path, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"\nüíæ Saved to {os.path.basename(config_path)}")
        except Exception as e:
            print(f"Error saving config: {e}")
    
    def audio_callback(self, outdata, frames, time, status):
        """Audio callback with crossfade looping."""
        if status:
            print(f"Audio status: {status}")
        
        if self.audio_data is None or not self.is_playing:
            outdata[:] = np.zeros((frames, 2), dtype=np.float32)
            return
        
        # Calculate positions
        end_pos = self.position + frames
        
        # Normal playback (no loop needed)
        if end_pos <= len(self.audio_data):
            chunk = self.audio_data[self.position:end_pos]
            self.position = end_pos
            
        else:
            # Need to loop with crossfade
            remaining = len(self.audio_data) - self.position
            wrap_amount = frames - remaining
            
            # Get segments
            end_segment = self.audio_data[self.position:]
            start_segment = self.audio_data[:wrap_amount]
            
            # Apply crossfade if we have enough samples
            cf_samples = self.crossfade_samples
            if (cf_samples > 0 and 
                remaining >= cf_samples and 
                wrap_amount >= cf_samples):
                
                # Create fade curves
                fade_out = np.linspace(1.0, 0.0, cf_samples).reshape(-1, 1)
                fade_in = np.linspace(0.0, 1.0, cf_samples).reshape(-1, 1)
                
                # Apply fades
                end_segment[-cf_samples:] *= fade_out
                start_segment[:cf_samples] *= fade_in
            
            # Combine
            chunk = np.vstack((end_segment, start_segment))
            self.position = wrap_amount
            self.loops_completed += 1
            
            # If in play-once mode, stop after loop
            if self.play_once_mode and self.loops_completed >= 1:
                self.is_playing = False
                self.play_once_mode = False
        
        # Output
        outdata[:] = chunk
    
    def adjust_crossfade(self, delta_ms):
        """Adjust crossfade time."""
        old_ms = self.crossfade_ms
        new_ms = max(0, min(30000, self.crossfade_ms + delta_ms))  # Max 30 seconds
        
        if new_ms != old_ms:
            self.crossfade_ms = new_ms
            self.crossfade_samples = int(new_ms * self.sample_rate / 1000)
            
            # Auto-save when changed
            self.save_config()
            
            return True
        
        return False
    
    def display_status(self):
        """Display current testing status."""
        os.system('clear' if os.name == 'posix' else 'cls')
        
        print("\n" + "="*60)
        print(f"TESTING: {self.filename}")
        print("="*60)
        print(f"Duration: {self.file_duration:.1f} seconds")
        print(f"Position: {self.position/self.sample_rate:.1f}s / {self.file_duration:.1f}s")
        print(f"Loops completed: {self.loops_completed}")
        print(f"Crossfade: {self.crossfade_ms} ms")
        print("="*60)
        
        # Visual bar (0-30 seconds)
        bar_length = 40
        filled = int((self.crossfade_ms / 30000) * bar_length)
        bar = "‚ñà" * filled + "‚ñë" * (bar_length - filled)
        print(f"Crossfade: [{bar}] {self.crossfade_ms} ms")
        
        print("\n" + "="*60)
        print("CONTROLS:")
        print("  ‚Üë/‚Üì: Adjust crossfade ¬±100ms")
        print("  U/D: Adjust crossfade ¬±1000ms")
        print("  P:   Play/Pause")
        print("  L:   Play loop once (hear crossfade)")
        print("  C:   Continuous play")
        print("  R:   Reset playback position")
        print("  S:   Save current crossfade to file")
        print("  N:   New file")
        print("  Q:   Quit")
        print("="*60)
        
        if self.is_playing:
            if self.play_once_mode:
                print("‚èµ Playing ONCE (will stop after loop)")
            elif self.continuous_mode:
                print("‚èµ CONTINUOUS play")
            else:
                print("‚èµ Playing")
        else:
            print("‚è∏ Paused")
        
        print("\nPress key: ", end='', flush=True)
    
    def run(self):
        """Main interactive loop."""
        # Setup terminal
        self.setup_terminal()
        
        try:
            # Select initial file
            if not self.select_file():
                return
            
            # Setup audio stream
            self.stream = sd.OutputStream(
                samplerate=self.sample_rate,
                blocksize=self.buffer_size,
                channels=2,
                callback=self.audio_callback,
                dtype=np.float32
            )
            self.stream.start()
            
            # Main interactive loop
            last_display = time.time()
            
            while self.running:
                # Display status periodically
                if time.time() - last_display > 0.1:  # 10Hz update
                    self.display_status()
                    last_display = time.time()
                
                # Check for keyboard input
                if select.select([sys.stdin], [], [], 0.1)[0]:
                    key = sys.stdin.read(1).lower()
                    self.handle_key(key)
                
                # If continuous mode and not playing, restart
                if (self.continuous_mode and 
                    not self.is_playing and 
                    self.audio_data is not None):
                    self.position = 0
                    self.is_playing = True
            
            # Cleanup
            self.stream.stop()
            self.stream.close()
            
        except KeyboardInterrupt:
            print("\n\nInterrupted by user")
        except Exception as e:
            print(f"\nError: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.restore_terminal()
            print("\nGoodbye!\n")
    
    def handle_key(self, key):
        """Handle keyboard input."""
        # Arrow keys (escape sequences)
        if key == '\x1b':
            # Read next two chars
            next1 = sys.stdin.read(1)
            next2 = sys.stdin.read(1)
            if next1 == '[':
                if next2 == 'A':  # Up arrow
                    if self.adjust_crossfade(100):
                        print(f" ‚Üë Crossfade: {self.crossfade_ms}ms")
                elif next2 == 'B':  # Down arrow
                    if self.adjust_crossfade(-100):
                        print(f" ‚Üì Crossfade: {self.crossfade_ms}ms")
            return
        
        # Regular keys
        if key == 'q':
            self.running = False
        
        elif key == 'p':
            self.is_playing = not self.is_playing
            self.continuous_mode = False
            self.play_once_mode = False
            print(f" {'‚èµ Playing' if self.is_playing else '‚è∏ Paused'}")
        
        elif key == 'l':  # Play once
            self.is_playing = True
            self.continuous_mode = False
            self.play_once_mode = True
            self.loops_completed = 0
            print(" ‚èµ Playing ONCE (will stop after loop)")
        
        elif key == 'c':  # Continuous
            self.is_playing = True
            self.continuous_mode = True
            self.play_once_mode = False
            print(" ‚èµ CONTINUOUS play")
        
        elif key == 'r':  # Reset position
            self.position = 0
            self.loops_completed = 0
            print(" ‚Ü∫ Reset position to start")
        
        elif key == 's':  # Save
            self.save_config()
        
        elif key == 'n':  # New file
            self.is_playing = False
            if self.select_file():
                self.display_status()
        
        elif key == 'u':  # Big increase
            if self.adjust_crossfade(1000):
                print(f" ‚Üó Crossfade: {self.crossfade_ms}ms")
        
        elif key == 'd':  # Big decrease
            if self.adjust_crossfade(-1000):
                print(f" ‚Üò Crossfade: {self.crossfade_ms}ms")
        
        elif key == ' ':
            # Space also toggles play/pause
            self.is_playing = not self.is_playing
            print(f" {'‚èµ Playing' if self.is_playing else '‚è∏ Paused'}")

def main():
    """Main entry point."""
    tester = CrossfadeTester()
    tester.run()

if __name__ == "__main__":
    main()
